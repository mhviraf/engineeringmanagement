* Organizational design is primarily about putting the right people in the right places to be empowered to make the right decisions and to be held accountable for their results.
* Org charts are always out of sync with reality, much like a software architecture document soon after actual development starts. 
* lithmus tests for whether a reorg is approperiate
   * is the problem structural? reorgs offer oppertunities to increase communication, reduce decision friction, and increase focus.
   * are you reoganizing to work around a broken relationship? solve the underlying issue.
   * does the problem already exist? don't reorg for future problems.
   * are the conditions temporary? 
* lithmus tests for teams in an org (during and after a reorg)
   * can you write a crisp mission statement for each team?
   * would you personally be excited to be a member of each of the teams? or directly manage each one.
   * can you define clear interfaces for each team?
* For ICs, reorgs can bring a lot of fear, doubt and uncertainty because it breaks down established forms of communication and splits up teams and ICs that were just starting to get their mojo. Often, it's seen as a time and effort drain that is more likely to set the business back than to move it forward. 
* Excessive amount of responsibilities and domains may lead to too much congnitive load for a team, and consequently lack of bandwidth to pursue mastery of their trade and struggles with the costs of switching context. Ultimately, the team becomes a delivery bottleneck, leading to delays, quality issues, and often a decrease in team members' motivation (See Intrinsic motivators in [Motivation](motivation.md))
* If the architecture of the system and the architecture of the organization are at odds, the architecture of the organization wins ([Conway's law](https://en.wikipedia.org/wiki/Conway%27s_law)). Thus, we need to understand what software architecture is needed _before_ we organize our teams. Hence, organizational design requires technical expertise. They are two sides of the same coin, thus both need to be undertaken by the same group of people. 
* Use small (6-8 ICs per team is the sweet spot) and durable teams as the standard building blocks of the organization. Teams should be stable but not static, changing only occasionally and when necessary. 
* The team owns the software. Team ownership provides the vital continuity of care that modern systems need. A problem of everyone is a problem of no one. The danger of allowing multiple teams to change the same system is that no one owns either the change or the resulting mess.
* Restrict team responsibilities to match the maximum team cognitive load. Rules of thumb for distributing domains among teams:
   * Ideally, assign each team with a single domain. If the domain is too large for one team, instead of splitting responsibilities of a single team to multiple teams, first split the domain into subdomains and then assign each subdomain to a single team.
   * A single team should be able to accommodate two or three "simple" domains.
   * A team owning a complex domain should not have any more domains assigned to them, not even a simple one. 
* The success of a team does not depend only on the team members' skills and experience; it also depends on (perhaps more importantly) the surrounding environment, teams, and interactions.